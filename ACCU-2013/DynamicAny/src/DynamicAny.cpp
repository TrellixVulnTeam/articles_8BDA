//
// DynamicAny.cpp
//
// $Id: //poco/svn/Foundation/samples/dir/src/DynamicAny.cpp#1 $
//
// This sample tests DynamicAny in comparison with similar classes.
//
// Copyright (c) 2008, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Any.h"
#include "Poco/DynamicAny.h"
#include "Poco/Stopwatch.h"
#include "Poco/FileStream.h"
#include "Poco/NumberParser.h"
#include "Poco/Exception.h"
#include "boost/lexical_cast.hpp"
#include "boost/any.hpp"
#include "UDT.h"
#include <list>
#include <iostream>
#include <cassert>


using Poco::Any;
using Poco::AnyCast;
using Poco::RefAnyCast;
using Poco::UnsafeAnyCast;
using Poco::DynamicAny;
using Poco::Stopwatch;
using Poco::NumberParser;
using Poco::FileOutputStream;
using Poco::Int32;
using Poco::UInt16;
using Poco::RangeException;
using Poco::InvalidArgumentException;


void staticCastInt32ToDouble(double& d, int i);
void unsafeAnyCastAnyToDouble(double& d, Any& a);
void lexicalCastInt32ToDouble(double& d, int i);
void convertInt32ToDouble(double& d, DynamicAny& da);
void assignInt32ToDouble(double& d, DynamicAny& da);
void lexicalCastInt32toUInt16(UInt16& us, Int32 j);
void convertInt32toUInt16(UInt16& us, DynamicAny& da);
void assignInt32toUInt16(UInt16& us, DynamicAny& da);
void lexicalCastStringToDouble(double& d, std::string& s);
void convertStringToDouble(double& d, DynamicAny& ds);
void assignStringToDouble(double& d, DynamicAny& ds);
void anyCastRefDouble(double& d, Any& a);
void anyCastPtrDouble(double& d, Any& a);
void extractDouble(double& d, DynamicAny& da);
void anyCastRefString(std::string& s, Any& as);
void anyCastPtrString(std::string& s, Any& as);
void extractString(std::string& s, DynamicAny& ds);


Poco::FileOutputStream fos("DynamicAny.csv");


void print(const std::string& name, Poco::Timestamp::TimeDiff time)
{
	std::cout << name << ": " << time/1000.0 <<  " ms" << std::endl;
	fos << name << '\t' << time/1000.0 << std::endl;
}


void listingOne()
{
	std::list<boost::any> al;
	int i = 0;
	std::string s = "1";

	al.push_back(i);
	al.push_back(s);
}


bool isInt(const boost::any& a)
{
	return a.type() == typeid(int);
}


void listingThree()
{
	DynamicAny any("42");
	int i = any;
	assert (i == 42);
	any = 65536;
	std::string s = any.toString();
	assert (s == "65536");
	try 
	{
		char c;
		c = any; // too big, throws RangeException
	}
	catch (RangeException&) { return; }

	assert(false);
}


void listingFour()
{
	DynamicAny any = 10;
	int i = any - 5;
	assert (i == 5);
	i += any;
	assert (i == 15);
	i = 30 / any;
	assert (i == 3);
	bool b = 10 == any;
	assert (b);
}


void listingFive()
{
	DynamicAny any = 10;
	any++;
	assert (any == 11);
	--any;
	assert (any == 10);
	any = 1.2f; // make it float
	try
	{
		++any; // throws InvalidArgumentException
	}
	catch (InvalidArgumentException&) { return; }
	assert (false);
}


void listingSix()
{
	DynamicAny any("42");
	std::string s1 = any.toString(); //OK
	//std::string s2(any); //compile error
	std::string s3(any.convert<std::string>()); //OK
}


void doUDT()
{
	SSN udt1(123456789);
	DynamicAny da = udt1;
	std::string ssn = da.toString();
	int i = da;
	std::cout << ssn << std::endl;
	SSN udt2 = da;
	std::cout << udt2.nSSN() << std::endl;
}


void compareSizes()
{
	std::cout << "int        :" << sizeof(int) << std::endl;
	std::cout << "boost::any :" << sizeof(boost::any) << std::endl;
	std::cout << "Poco::Any  :" << sizeof(Any) << std::endl;
	std::cout << "DynamicAny :" << sizeof(DynamicAny) << std::endl;
}


void checkListings()
{
	listingOne();
	boost::any ai = 1; assert (isInt(ai));
	listingThree();
	listingFour();
	listingFive();
	listingSix();
	doUDT();
	compareSizes();
}


void doPerformance(int count)
{
	std::cout << "Loop count: " << count << std::endl;

	std::cout << "Static cast Int32 to double:" << std::endl;
	std::cout << "--------------------------" << std::endl;
	fos << "Static cast Int32 to double" << std::endl;

	Int32 i = 0;
	double d;
	Stopwatch sw; sw.start();
	do { staticCastInt32ToDouble(d, i); }
	while (++i < count); sw.stop();
	print("static_cast<double>(Int32)", sw.elapsed());

	Any a = 1.0;
	i = 0; sw.start();
	do { unsafeAnyCastAnyToDouble(d, a); }
	while (++i < count); sw.stop();
	print("UnsafeAnyCast<double>(Int32)", sw.elapsed());

	std::cout << std::endl
		 << "Conversion Int32 to double:" << std::endl;
	std::cout << "--------------------------" << std::endl;
	fos << "Conversion Int32 to double" << std::endl;

	i = 0; sw.start();
	do { lexicalCastInt32ToDouble(d, i); }
	while (++i < count); sw.stop();
	print("boost::lexical_cast<double>(Int32)", sw.elapsed());

	DynamicAny da = 1;
	i = 0; sw.restart();
	do { convertInt32ToDouble(d, da); }
	while (++i < count); sw.stop();
	print("DynamicAny<Int32>::convert<double>()", sw.elapsed());

	i = 0; sw.restart();
	do { assignInt32ToDouble(d, da); }
	while (++i < count); sw.stop();
	print("operator=(double, DynamicAny<Int32>)", sw.elapsed());


	std::cout << std::endl
		 << "Conversion signed Int32 to UInt16:" << std::endl;
	std::cout << "--------------------------" << std::endl;
	fos << "Conversion signed Int32 to UInt16" << std::endl;

	UInt16 us = 0; Int32 j = 1; i = 0; sw.start();
	do { lexicalCastInt32toUInt16(us, j); }
	while (++i < count); sw.stop();
	print("boost::lexical_cast<UInt16>(Int32)", sw.elapsed());

	i = 0; sw.restart();
	do { convertInt32toUInt16(us, da); }
	while (++i < count); sw.stop();
	print("DynamicAny<Int32>::convert<UInt16>()", sw.elapsed());

	i = 0; sw.restart();
	do { assignInt32toUInt16(us, da); }
	while (++i < count); sw.stop();
	print("operator=(UInt16, DynamicAny<Int32>)", sw.elapsed());

	std::cout << std::endl
		<< "Conversion string to double:" << std::endl;
	std::cout << "-----------" << std::endl;
	fos << "Conversion string to double" << std::endl;

	std::string s = "1234.5";
	i = 0;
	sw.start();
	do { lexicalCastStringToDouble(d, s); }
	while (++i < count); sw.stop();
	print("boost::lexical_cast<double>(string)", sw.elapsed());

	DynamicAny ds = "1234.5";
	i = 0; sw.restart();
	do { convertStringToDouble(d, ds); }
	while (++i < count); sw.stop();
	print("DynamicAny<string>::convert<double>()", sw.elapsed());

	i = 0; sw.restart();
	do { assignStringToDouble(d, ds); }
	while (++i < count); sw.stop();
	print("operator=(double, DynamicAny<string>)", sw.elapsed());

	std::cout << std::endl
		<< "Extraction double:" << std::endl;
	std::cout << "-----------" << std::endl;
	fos << "Extraction double" << std::endl;

	a = 1.0;
	i = 0; sw.restart();
	do { anyCastRefDouble(d, a); }
	while (++i < count); sw.stop();
	print("RefAnyCast<double>(Any&)", sw.elapsed());

	i = 0; sw.restart();
	do { anyCastPtrDouble(d, a); }
	while (++i < count); sw.stop();
	print("AnyCast<double>(Any*)", sw.elapsed());

	da = 1.0; i = 0;
	sw.restart();
	do { extractDouble(d, da); }
	while (++i < count); sw.stop();
	print("DynamicAny::extract<double>()", sw.elapsed());


	std::cout << std::endl
		<< "Extraction string:" << std::endl;
	std::cout << "-----------" << std::endl;
	fos << "Extraction string" << std::endl;

	Any as = std::string("1234.5");
	i = 0; sw.restart();
	do { anyCastRefString(s, as); }
	while (++i < count); sw.stop();
	print("RefAnyCast<std::string>(Any&)", sw.elapsed());

	i = 0; sw.restart();
	do { anyCastPtrString(s, as); }
	while (++i < count); sw.stop();
	print("AnyCast<std::string>(Any*)", sw.elapsed());

	ds = "1234.5"; i = 0;
	sw.restart();
	do { extractString(s, ds); }
	while (++i < count); sw.stop();
	print("DynamicAny::extract<std::string>()", sw.elapsed());

	fos.close();
}

#include "Poco/Dynamic/Struct.h"
int main(int argc, char** argv)
{
	checkListings();

	int count = 5000000;

	if (argc > 1)
	{
		std::string strCount(argv[1]); 
		if (!NumberParser::tryParse(strCount, count))
		{
			std::cerr << 
				"Invalid number specified as loop count: " << 
				strCount << 
				std::endl;

			return -1;
		}
	}

	doPerformance(count);

	return 0;
}

